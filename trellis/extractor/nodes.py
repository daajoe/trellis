import copy
from itertools import permutations


def bfs_list(decomp, max_bag_size=None, budget=50):
    # get the bags from the tree decomposition
    bag_lengths = dict(zip(decomp[1].keys(), map(len, decomp[1].values())))

    # root of the BFS is the bag with max elements
    root_id = decomp.get_first_node(bag_lengths.values(), size=max_bag_size)
    root = bag_lengths.keys()[root_id]
    bfs_queue = [root]
    bfs_depth = dict()
    # initialization for BFS
    for i in decomp[0].nodes():
        bfs_depth[i] = -1
    bfs_depth[root] = 0
    internal_nodes = []
    sub_vertices = set(decomp[1][root])
    # root is the internal node should not be deleted from the local tree
    internal_nodes.append(root)
    # maybe change this part Not sure how to avoid this.
    while bfs_queue:
        # show_graph(decomp[0], 1)
        v2 = bfs_queue.pop(0)
        flag = 0
        # if any of the neighbours have a bag of size > current bag do not continue on this bag
        for w in decomp[0][v2]:
            if bfs_depth[w] == -1:
                if bag_lengths[w] > bag_lengths[v2]:
                    flag = 1
                    break

        if flag == 0:
            for w in decomp[0][v2]:
                if bfs_depth[w] == -1:
                    bfs_depth[w] = bfs_depth[v2]
                    if bag_lengths[w] == bag_lengths[v2]:
                        bfs_depth[w] = 0
                if w not in bfs_queue and w not in internal_nodes:
                    bfs_queue.append(w)
                if w not in internal_nodes:
                    internal_nodes.append(w)
                    sub_vertices |= decomp[1][w]
        if len(sub_vertices) >= budget:
            break
            # show_graph(decomp[0],1)
    return internal_nodes, sub_vertices


def extract_graph(internal_nodes, sub_vertices, decomp, g):
    """
    generates graph for the local tree decomposition
    ASSUMPTION: vertices have not been relabelled
    :param g: input graph type: Networkx Graph
    :param internal_nodes: nodes of tree decomposition which are picked by BFS  type: list
    :param sub_vertices: vertices of graph which appear in the local tree decomposition type: list
    :param decomp: Tree decomposition type: Networkx Graph
    :return: sub_graph: graph generated by the local tree decomposition by adding clique for all leaf nodes/bags type: networkx graph
    :return: rest_decomp: Sub Tree Decomposition after removing the local tree decomposition type: networkx Graph
    :return: connecting_leave: The leaves where local tree decomposition connects with the rest_decomp type:list
-    """
    y = decomp[0].subgraph(internal_nodes)
    connecting_nodes = {}
    sub_graph = g.subgraph(sub_vertices)
    for leaf, degree in y.degree().iteritems():
        if degree != 1:
            continue
        if decomp[0].degree(leaf) > y.degree(leaf):
            internal_nodes.remove(leaf)
            connecting_nodes[leaf] = decomp[1][leaf]
        for i, j in permutations(decomp[1][leaf], r=2):
            sub_graph.add_edge(i, j)
    rest_decomp = decomp[0].subgraph(set(decomp[0].nodes()) - set(internal_nodes))
    for i in internal_nodes:
        del decomp[1][i]

    return sub_graph, (rest_decomp, decomp[1]), connecting_nodes


def extract_decomp(decomp, g, max_bag_size=None, budget=50):
    internal_nodes, sub_vertices = bfs_list(decomp, max_bag_size=max_bag_size, budget=budget)
    sub_graph, rest_decomp, connecting_nodes = extract_graph(internal_nodes, sub_vertices, copy.deepcopy(decomp), g)
    return rest_decomp, sub_graph, connecting_nodes

def get_connecting_nodes(decomp, connecting_leaves):
    connecting_bags = {}
    for i in connecting_leaves:
        connecting_bags[i] = decomp[1][i]
    return connecting_bags
