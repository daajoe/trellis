import copy
import time
from collections import defaultdict
from distutils.spawn import find_executable
from itertools import count, izip, ifilter, repeat, permutations
from subprocess import Popen, PIPE, call
import networkx as nx
from utils.graph_utils import *
from utils.htd_utils import *
from utils.viz_utils import *


# NEW VERSION
def get_first_node_of_bag_size(bag_lengths, size=None):
    if not size:
        size = max(bag_lengths)
    return bag_lengths.index(size)

def bfs_list_edge(decomp, max_bag_size=None, budget=50):
    # get the bags from the tree decomposition
    """

    :param budget: the number of vertices in the local decomp
    :param max_bag_size: the bagsize from where we want to start bfs
    :type decomp: decomposition
    """
    rest_decomp=copy.deepcopy(decomp)
    bag_lengths = dict(zip(decomp[1].keys(), map(len, decomp[1].values())))
    bags = decomp[1]
    # root of the BFS is the bag with max elements
    root_id = get_first_node_of_bag_size(bag_lengths.values(), size=max_bag_size)
    root = bag_lengths.keys()[root_id]
    bfs_queue = [root]
    bfs_depth = dict()
    bfs_common_nodes = {}
    parent={}
    # initialization for BFS
    for i in decomp[0].nodes():
        bfs_depth[i] = -1
        parent[i]=-1
    bfs_depth[root] = 0
    parent[root]=root
    internal_nodes = []
    bfs_common_nodes[root] = decomp[1][root]
    sub_vertices = set(decomp[1][root])
    # root is the internal node should not be deleted from the local tree
    internal_nodes.append(root)
    # maybe change this part Not sure how to avoid this.
    while bfs_queue:
        v2 = bfs_queue.pop(0)
        flag = 0
        # if any of the neighbours have a bag of size > current bag do not continue on this bag
        # changing the checking to the intersection of two bags i.e. check how many vertices are common.
        for w in decomp[0][v2]:
            if bfs_depth[w] == -1:
                parent[w]=v2
                if len(bags[w].intersection(bags[v2])) >= len(bfs_common_nodes[v2]):
                    flag = 1
                    break

        if flag == 0:
            for w in decomp[0][v2]:
                if bfs_depth[w] == -1:
                    bfs_depth[w] = bfs_depth[v2] + 1
                    bfs_common_nodes[w] = bags[w].intersection(bags[v2])
                if w not in bfs_queue and w not in internal_nodes:
                    bfs_queue.append(w)
                if w not in internal_nodes:
                    internal_nodes.append(w)
                    sub_vertices |= decomp[1][w]
        if flag==1:
            new_node=max(rest_decomp[0].nodes())+1
            rest_decomp[0].add_node(new_node)
            rest_decomp[0].add_edge(new_node,v2)
            rest_decomp[0].add_edge(new_node,parent[v2])
            rest_decomp[0].remove_edge(v2,parent[v2])
            rest_decomp[1][new_node]=set(bfs_common_nodes[v2])
            if v2 in internal_nodes:
                internal_nodes.remove(v2)
            if new_node not in internal_nodes:
                internal_nodes.append(new_node)
        if len(sub_vertices) >= budget:
            break
    return internal_nodes, sub_vertices, rest_decomp



def complete_graph(vertices):
    g1 = nx.complete_graph(len(vertices))
    g1 = nx.relabel_nodes(g1, mapping=dict(izip(g1.nodes(), vertices)), copy=True)
    return g1

def extract_graph_edge(internal_nodes, sub_vertices, decomp, g):
    """
    generates graph for the local tree decomposition
    ASSUMPTION: vertices have not been relabelled
    :return:
    :param g: input graph type: Networkx Graph
    :param internal_nodes: nodes of tree decomposition which are picked by BFS  type: list
    :param sub_vertices: vertices of graph which appear in the local tree decomposition type: list
    :param decomp: Tree decomposition type: Networkx Graph
    :return: sub_graph: graph generated by the local tree decomposition by adding clique for all leaf nodes/bags type: networkx graph
    :return: rest_decomp: Sub Tree Decomposition after removing the local tree decomposition type: networkx Graph
    :return: connecting_leave: The leaves where local tree decomposition connects with the rest_decomp type:list
-    """
    y = decomp[0].subgraph(internal_nodes)
    sub_nodes=set()
    for n in y.nodes():
        sub_nodes|=set(decomp[1][n])
    connecting_nodes = {}
    sub_graph = g.subgraph(sub_nodes)
    for leaf, degree in y.degree().iteritems():
        if degree != 1:
            continue
        if decomp[0].degree(leaf) > y.degree(leaf):
            internal_nodes.remove(leaf)
            connecting_nodes[leaf] = decomp[1][leaf]
        for i, j in permutations(decomp[1][leaf], r=2):
            sub_graph.add_edge(i, j)
    rest_decomp = decomp[0].subgraph(set(decomp[0].nodes()) - set(internal_nodes))
    for i in internal_nodes:
        del decomp[1][i]
    return sub_graph, (rest_decomp, decomp[1]), connecting_nodes


def extract_decomp_edge(decomp, g, max_bag_size=None, budget=50):
    # BFS for finding the local tree decomposition
    internal_nodes, sub_vertices, rest_decomp = bfs_list_edge(decomp, max_bag_size=max_bag_size, budget=budget)
    # generating the graph associated with the local tree decomposition
    sub_graph, rest_decomp, connecting_leaves = extract_graph_edge(internal_nodes, sub_vertices, copy.deepcopy(rest_decomp), g)
    return rest_decomp, sub_graph, connecting_leaves


def bag_contents(bags, nodes):
    ret = set()
    for i in nodes:
        ret.update(bags[i])
    return ret


def get_connecting_nodes(decomp, connecting_leaves):
    connecting_bags = {}
    for i in connecting_leaves:
        connecting_bags[i] = decomp[1][i]
    return connecting_bags


def relabel_sub_decomp(sub_decomp, offset, vertex_mapping):
    offset += 1
    tree_mapping = {org_id: id for id, org_id in izip(count(start=offset), sub_decomp[0].nodes_iter())}
    new_bags={}
    for i in xrange(offset,offset+len(sub_decomp[0].nodes())):
        new_bags[i]=sub_decomp[1][sub_decomp[0].nodes()[i-offset]]

    ret_tree=nx.relabel_nodes(sub_decomp[0], tree_mapping, copy=False)
    # relabel the contents of the bags according to mapping
    inv_mapping = dict(imap(reversed, vertex_mapping.items()))
    for key, bag in new_bags.iteritems():
        new_bags[key] = set(map(lambda x: inv_mapping[x], bag))
    # relabel the keys of the bags according to the relabeling above in the tree
    return (ret_tree,new_bags)

def connect_decomp(rest_decomp, sub_decomp, connecting_nodes):
    if rest_decomp[0].number_of_nodes()==0:
        return (sub_decomp[0],sub_decomp[1])
    new_decomp = nx.union(rest_decomp[0], sub_decomp[0])
    for node, bag in connecting_nodes.iteritems():
        connect = True
        for key, value in sub_decomp[1].iteritems():
            rest_decomp[1][key] = value
            if bag.issubset(value) and connect:
                new_decomp.add_edge(node, key)
                connect = False
    return (new_decomp, rest_decomp[1])

# noinspection PyRedundantParentheses
def connect_decomp_edge(rest_decomp, sub_decomp, connecting_nodes):
    new_decomp = nx.union(rest_decomp[0], sub_decomp[0])
    for key, value in sub_decomp[1].iteritems():
        rest_decomp[1][key] = value
    for node, bag in connecting_nodes.iteritems():
        for key, value in sub_decomp[1].iteritems():
            if bag.issubset(value):
                new_decomp.add_edge(node, key)
                break
    return (new_decomp, rest_decomp[1])


def convert_to_small_decomposition(decomp):
    (tree, bags) = decomp
    node = iter(tree.nodes())
    while True:
        try:
            i = next(node)
            neigh_list = set(tree[i])
            for neigh in tree[i]:
                if bags[i].issubset(bags[neigh]):
                    for neigh1 in neigh_list - set([neigh]):
                        tree.add_edge(neigh, neigh1)
                    tree.remove_node(i)
                    del bags[i]
                    break
        except StopIteration:
            break
    return (tree,bags)
